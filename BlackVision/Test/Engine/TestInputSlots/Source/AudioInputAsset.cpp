#include "gtest/gtest.h"
#include "Framework/FrameworkTest.h"

#include "Engine/Graphics/InputSlots/InputSlots.h"
#include "Engine/Audio/Resources/AudioBuffer.h"

#include "Assets/Input/AudioInputAsset.h"
#include "Assets/Input/AudioInputAssetDesc.h"
#include "Assets/Input/Loaders/InputAssetLoader.h"

#include "Assets/AssetManager.h"

#include "Helpers/TextureHelpers.h"
#include "Helpers/InputAssetHelpers.h"



using namespace bv;



// ***********************
// Create AudioInputAsset with binding by slot index.
TEST( Engine_InputSlots, AudioInputAsset_Creation_BindByIndex )
{
    auto context = CreateInputContext();

    audio::AudioBufferPtr audio = audio::AudioBuffer::Create( MemoryChunk::Create( 3840 ), 48000, AudioFormat::STEREO16, false );
    Expected< SlotIndex > slot1Idx = context.slots->RegisterSource( InputSlot( audio ), "Source1" );

    ASSERT_TRUE( slot1Idx.IsValid() );

    auto desc = AudioInputAssetDesc::Create( InputSlotBinding( slot1Idx ) );
    auto asset = context.assetManager->LoadAsset( desc );

    ASSERT_NE( asset, nullptr );
    ASSERT_EQ( asset->GetUID(), AudioInputAsset::UID() );

    auto typedAsset = std::static_pointer_cast< const AudioInputAsset >( asset );

    EXPECT_EQ( typedAsset->GetFrame(), audio->GetData() );
}

// ***********************
// Create AudioInputAsset with binding by slot name.
TEST( Engine_InputSlots, AudioInputAsset_Creation_BindByName )
{
    auto context = CreateInputContext();

    audio::AudioBufferPtr audio = audio::AudioBuffer::Create( MemoryChunk::Create( 3840 ), 48000, AudioFormat::STEREO16, false );
    Expected< SlotIndex > slot1Idx = context.slots->RegisterSource( InputSlot( audio ), "Source1" );

    ASSERT_TRUE( slot1Idx.IsValid() );

    auto desc = AudioInputAssetDesc::Create( InputSlotBinding( "Source1" ) );
    auto asset = context.assetManager->LoadAsset( desc );

    ASSERT_NE( asset, nullptr );
    ASSERT_EQ( asset->GetUID(), AudioInputAsset::UID() );

    auto typedAsset = std::static_pointer_cast< const AudioInputAsset >( asset );

    EXPECT_EQ( typedAsset->GetFrame(), audio->GetData() );
}

// ***********************
// Create AudioInputAsset providing index to empty slot. Asset should return fallback audio
// generated by InputSlot object.
TEST( Engine_InputSlots, AudioInputAsset_Creation_EmptySlot )
{
    auto context = CreateInputContext();

    // InputSlot should return valid fallback slot. Input slot 30 doesn't exist.
    ASSERT_NE( context.slots->GetFallbackSlot().Audio, nullptr );
    ASSERT_FALSE( context.slots->AccessSource( 30 ).IsValid() );

    // Not existing input slot.
    auto desc = AudioInputAssetDesc::Create( InputSlotBinding( 30 ) );
    auto asset = context.assetManager->LoadAsset( desc );

    // Asset should be created even if slot is empty.
    ASSERT_NE( asset, nullptr );
    ASSERT_EQ( asset->GetUID(), AudioInputAsset::UID() );

    auto typedAsset = std::static_pointer_cast< const AudioInputAsset >( asset );

    ASSERT_EQ( typedAsset->GetFrame(), context.slots->GetFallbackSlot().Audio->AudioBuffer->GetData() );
}

