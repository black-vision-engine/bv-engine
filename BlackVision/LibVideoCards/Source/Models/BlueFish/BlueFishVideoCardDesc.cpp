#include "BlueFishVideoCardDesc.h"
#include "BlueFishVideoCard.h"

#include "Serialization/ConversionHelper.h"

#include "Mathematics/Core/mathfuncs.h"

#include "Models/BlueFish/Input/InputChannel.h"
#include "Models/BlueFish/Output/OutputChannel.h"

#include "Exceptions/ExceptionsList.h"

#include "UseLoggerVideoModule.h"


#include <set>


namespace bv {
namespace videocards {
namespace bluefish
{

// ***********************
//
std::string      VideoCardDesc::sUID = "BlueFish";


//**************************************
//
VideoCardDesc::VideoCardDesc    ()
{}

//**************************************
//
Expected< IVideoCardPtr >   VideoCardDesc::CreateVideoCard          () const
{
    auto result = Validate();

    if( !result.IsValid() )
        return result.GetError();

    auto card = std::make_shared< VideoCard >( m_deviceID );

    if( card->AttachVideoCard() )
    {
        for( auto & channelDesc : m_channels )
        {
            ChannelInputDataUPtr input = nullptr;
            ChannelOutputDataUPtr output = nullptr;

            // Copy input and output data from descriptor.
            if( channelDesc.InputChannelData )
            {
                input = std::unique_ptr< ChannelInputData >( new ChannelInputData( *( channelDesc.InputChannelData.get() ) ) );
                card->AddChannel( new InputChannel( channelDesc.Name, input ) );
            }

            if( channelDesc.OutputChannelData )
            {
                output = std::unique_ptr< ChannelOutputData >( new ChannelOutputData( *( channelDesc.OutputChannelData.get() ) ) );
                card->AddChannel( new OutputChannel( channelDesc.Name, output ) );
            }
        }

        card->InitVideoCard();
        return card;
    }
    else
        return "Can't attach Bluefish device.";
}

// ***********************
//
void                    VideoCardDesc::Deserialize          ( const IDeserializer & deser )
{
    m_deviceID = Convert::String2T< UInt32 >( deser.GetAttribute( "deviceID" ), 0 );


    //check input / output count
    if( deser.EnterChild( "channels" ) )
    {
        if( deser.EnterChild( "channel" ) )
        {
            do
            {
                ChannelInputDataUPtr input = nullptr;
                ChannelOutputDataUPtr output = nullptr;

                auto name = Convert::String2T< ChannelName >( deser.GetAttribute( "name" ) );

                if( deser.EnterChild( "input" ) )
                {
                    input = std::unique_ptr< ChannelInputData >( new ChannelInputData() );
                    input->type = Convert::String2T< IOType >( deser.GetAttribute( "type" ) );
                    input->resolution = Convert::String2T< UInt32 >( deser.GetAttribute( "resolution" ), 1080 );
                    input->playthrough = Convert::String2T< bool >( deser.GetAttribute( "playthrough" ), false );
                    input->linkedVideoInput = Convert::String2T< UInt32 >( deser.GetAttribute( "linkedVideoInput" ), 0 );

                    input->updateFormat = UPD_FMT_FIELD;
                    input->memoryFormat = MEM_FMT_BGRA;

                    deser.ExitChild(); //input
                }

                if( deser.EnterChild( "output" ) )
                {
                    output = std::unique_ptr< ChannelOutputData >( new ChannelOutputData() );
                    output->type = Convert::String2T< IOType >( deser.GetAttribute( "type" ) );
                    output->resolution = Convert::String2T< UInt32 >( deser.GetAttribute( "resolution" ), 1080 );
                    output->refresh = Convert::String2T< UInt32 >( deser.GetAttribute( "refresh" ), 5000 );
                    output->interlaced = Convert::String2T< bool >( deser.GetAttribute( "interlaced" ), false );
                    output->flipped = Convert::String2T< bool >( deser.GetAttribute( "flipped" ), false );
                    output->referenceMode = ReferenceModeMap[ Convert::String2T< ReferenceMode >( deser.GetAttribute( "referenceMode" ) ) ];
                    output->referenceH = Convert::String2T< Int32 >( deser.GetAttribute( "referenceH" ), 0 );
                    output->referenceV = Convert::String2T< Int32 >( deser.GetAttribute( "referenceV" ), 0 );
                    output->videoMode = ConvertVideoMode( output->resolution, output->refresh, output->interlaced );
                    output->linkedVideoOutput = ( UInt32 )Convert::String2T< UInt32 >( deser.GetAttribute( "linkedVideoOutput" ), 0 );

                    //FIXME?
                    output->updateFormat = UPD_FMT_FIELD;
                    output->memoryFormat = MEM_FMT_BGRA;
                    output->timecodePresented = true;
                    output->autoGeneratedTimecode = true;
                    //FIXME? END

                    deser.ExitChild(); //output
                }

                m_channels.push_back( ChannelDesc( name, input, output ) );

            } while( deser.NextChild() );

            deser.ExitChild(); //channel
        }

        deser.ExitChild(); //channels
    }

}


// ***********************
//
ReturnResult            VideoCardDesc::Validate() const
{
    ExceptionsListPtr errors = std::make_shared< ExceptionsList >();

    errors->Merge( ValidateUniqueChannelNames() );
    errors->Merge( ValidateVideoMode() );

    if( errors->IsEmpty() )
        return Result::Success();

    return std::static_pointer_cast< Exception >( errors );
}

//**************************************
//
ExceptionsListPtr       VideoCardDesc::ValidateUniqueChannelNames   () const
{
    ExceptionsListPtr errors = std::make_shared< ExceptionsList >();

    for( int i = 0; i < m_channels.size(); ++i )
    {
        if( m_channels[ i ].InputChannelData )
        {
            for( int j = i + 1; j < m_channels.size(); ++j )
            {
                if( m_channels[ j ].InputChannelData &&
                    m_channels[ i ].Name == m_channels[ j ].Name )
                {
                    errors->AddException( "Duplicated input channel " + Convert::T2String( m_channels[ i ].Name ) + " in config file." );
                }
            }
        }
        else if( m_channels[ i ].OutputChannelData )
        {
            for( int j = i + 1; j < m_channels.size(); ++j )
            {
                if( m_channels[ j ].OutputChannelData &&
                    m_channels[ i ].Name == m_channels[ j ].Name )
                {
                    errors->AddException( "Duplicated output channel " + Convert::T2String( m_channels[ i ].Name ) + " in config file." );
                }
            }
        }
    }

    return errors;
}

// ***********************
//
ExceptionsListPtr       VideoCardDesc::ValidateVideoMode    () const
{
    ExceptionsListPtr errors = std::make_shared< ExceptionsList >();

    for( int i = 0; i < m_channels.size(); ++i )
    {
        if( m_channels[ i ].OutputChannelData )
        {
            if( m_channels[ i ].OutputChannelData->videoMode == VID_FMT_INVALID )
            {
                errors->AddException( "Channel " + Convert::T2String( m_channels[ i ].Name ) + ": Invalid video mode. " +
                    "Resolution: " + Convert::T2String( m_channels[ i ].OutputChannelData->resolution ) +
                    ", refresh: " + Convert::T2String( m_channels[ i ].OutputChannelData->refresh ) +
                    ", interlaced: " + Convert::T2String( m_channels[ i ].OutputChannelData->interlaced ) );
            }
        }
    }

    return errors;
}

//**************************************
//
const std::string &     VideoCardDesc::GetVideoCardUID      () const
{
    return UID();
}


}   // bluefish
}   // videocards
}   // bv



