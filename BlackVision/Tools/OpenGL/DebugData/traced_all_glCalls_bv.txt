Renderers\OGLRenderer\GLRenderer.cpp(30):            glEnable( GL_BLEND );
Renderers\OGLRenderer\GLRenderer.cpp(38):            glBlendFunc( srcBlendMode, dstBlendMode );
Renderers\OGLRenderer\GLRenderer.cpp(45):            glBlendColor( col[ 0 ], col[ 1 ], col[ 2 ], col[ 3 ] );
Renderers\OGLRenderer\GLRenderer.cpp(52):            glDisable( GL_BLEND );
Renderers\OGLRenderer\GLRenderer.cpp(76):            glEnable( GL_CULL_FACE );
Renderers\OGLRenderer\GLRenderer.cpp(77):            glFrontFace( GL_CCW );            
Renderers\OGLRenderer\GLRenderer.cpp(82):            glCullFace( cs->isCCWOrdered ? GL_BACK : GL_FRONT );
Renderers\OGLRenderer\GLRenderer.cpp(89):            glDisable( GL_CULL_FACE );
Renderers\OGLRenderer\GLRenderer.cpp(112):            glEnable( GL_DEPTH_TEST );
Renderers\OGLRenderer\GLRenderer.cpp(119):            glDepthFunc( compareMode );
Renderers\OGLRenderer\GLRenderer.cpp(126):            glDisable( GL_DEPTH_TEST );
Renderers\OGLRenderer\GLRenderer.cpp(132):        glDepthMask( ds->writable ? GL_TRUE : GL_FALSE );
Renderers\OGLRenderer\GLRenderer.cpp(154):        glPolygonMode( GL_FRONT_AND_BACK, fillMode );
Renderers\OGLRenderer\GLRenderer.cpp(174):        os->fillEnabled ? glEnable( GL_POLYGON_OFFSET_FILL ) : glDisable( GL_POLYGON_OFFSET_FILL );
Renderers\OGLRenderer\GLRenderer.cpp(179):        os->linesEnabled ? glEnable( GL_POLYGON_OFFSET_LINE ) : glDisable( GL_POLYGON_OFFSET_LINE );
Renderers\OGLRenderer\GLRenderer.cpp(184):        os->pointsEnabled ? glEnable( GL_POLYGON_OFFSET_POINT ) : glDisable( GL_POLYGON_OFFSET_POINT );
Renderers\OGLRenderer\GLRenderer.cpp(189):        glPolygonOffset( os->scale, os->bias );
Renderers\OGLRenderer\GLRendererData.cpp(20):        glEnable( state ); 
Renderers\OGLRenderer\GLRendererData.cpp(24):        glDisable( state );
Renderers\OGLRenderer\GLRendererData.cpp(76):    glBlendFunc( srcBlend, dstBlend );
Renderers\OGLRenderer\GLRendererData.cpp(78):    glBlendColor( blendColor[ 0 ], blendColor[ 1 ], blendColor[ 2 ], blendColor[ 3 ] );
Renderers\OGLRenderer\GLRendererData.cpp(88):    glFrontFace( GL_CCW );
Renderers\OGLRenderer\GLRendererData.cpp(89):    glCullFace( cs->isCCWOrdered ? GL_BACK : GL_FRONT );
Renderers\OGLRenderer\GLRendererData.cpp(101):    glDepthMask( ds->writable ? GL_TRUE : GL_FALSE );
Renderers\OGLRenderer\GLRendererData.cpp(102):    glDepthFunc( cmpFunc );
Renderers\OGLRenderer\GLRendererData.cpp(113):    glPolygonMode( GL_FRONT_AND_BACK, mode );
Renderers\OGLRenderer\GLRendererData.cpp(126):    glPolygonOffset( os->scale, os->bias );
Renderers\OGLRenderer\GLUtils.cpp(24):    glErr = glGetError();
Renderers\OGLRenderer\GLUtils.cpp(51):        glErr = glGetError();
Renderers\OGLRenderer\GLUtils.cpp(62):    const GLubyte * renderer    = glGetString( GL_RENDERER );
Renderers\OGLRenderer\GLUtils.cpp(63):    const GLubyte * vendor      = glGetString( GL_VENDOR );
Renderers\OGLRenderer\GLUtils.cpp(64):    const GLubyte * version     = glGetString( GL_VERSION );
Renderers\OGLRenderer\GLUtils.cpp(65):    const GLubyte * glslVersion = glGetString( GL_SHADING_LANGUAGE_VERSION );
Renderers\OGLRenderer\GLUtils.cpp(68):    glGetIntegerv( GL_MAJOR_VERSION, &major );
Renderers\OGLRenderer\GLUtils.cpp(69):    glGetIntegerv( GL_MINOR_VERSION, &minor );
Renderers\OGLRenderer\GLUtils.cpp(81):        glGetIntegerv( GL_NUM_EXTENSIONS, &nExtensions );
Renderers\OGLRenderer\GLUtils.cpp(85):            printf( "%s\n", glGetStringi( GL_EXTENSIONS, i ) );
Renderers\OGLRenderer\GLUtils.cpp(96):    glGetIntegerv( GL_MAX_VERTEX_ATTRIBS,  &r0 );
Renderers\OGLRenderer\GLUtils.cpp(97):    glGetIntegerv( GL_MAX_TEXTURE_UNITS,   &r1 );
Renderers\OGLRenderer\GLUtils.cpp(98):    glGetIntegerv( GL_MAX_TEXTURE_SIZE,    &r2 );
Renderers\OGLRenderer\GLUtils.cpp(99):    glGetIntegerv( GL_MAX_3D_TEXTURE_SIZE, &r3 );
Renderers\OGLRenderer\GLUtils.cpp(100):    glGetIntegerv( GL_MAX_DRAW_BUFFERS,    &r4 );
Renderers\OGLRenderer\GLUtils.cpp(101):    glGetIntegerv( GL_MAX_VARYING_FLOATS,  &r5 );
Renderers\OGLRenderer\GLUtils.cpp(103):    glGetIntegerv( GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, &r6 );
Renderers\OGLRenderer\GLUtils.cpp(104):    glGetIntegerv( GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS, &r7 );
Renderers\OGLRenderer\GLUtils.cpp(105):    glGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS, &r8 );
Renderers\OGLRenderer\GLUtils.cpp(106):    glGetIntegerv( GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &r9 );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(83):    glDeleteProgram( m_Handle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(98):        m_Handle = glCreateProgram();
Renderers\OGLRenderer\PdrGLSLProgram.cpp(130):        m_Handle = glCreateProgram();
Renderers\OGLRenderer\PdrGLSLProgram.cpp(142):        shaderHandle = glCreateShader( GL_VERTEX_SHADER );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(145):        shaderHandle = glCreateShader( GL_FRAGMENT_SHADER );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(148):        shaderHandle = glCreateShader( GL_GEOMETRY_SHADER );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(151):        shaderHandle = glCreateShader( GL_TESS_CONTROL_SHADER );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(154):        shaderHandle = glCreateShader( GL_TESS_EVALUATION_SHADER );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(161):    glShaderSource( shaderHandle, 1, &c_code, NULL );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(164):    glCompileShader( shaderHandle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(168):    glGetShaderiv( shaderHandle, GL_COMPILE_STATUS, &result );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(174):        glGetShaderiv(shaderHandle, GL_INFO_LOG_LENGTH, &length );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(178):            glGetShaderInfoLog(shaderHandle, length, &written, c_log);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(188):        glAttachShader( m_Handle, shaderHandle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(203):    glLinkProgram( m_Handle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(207):    glGetProgramiv( m_Handle, GL_LINK_STATUS, &status );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(215):        glGetProgramiv( m_Handle, GL_INFO_LOG_LENGTH, &length );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(221):            glGetProgramInfoLog( m_Handle, length, &written, c_log );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(242):    glUseProgram( m_Handle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(277):    glBindAttribLocation(m_Handle, location, name.c_str() );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(284):    glBindFragDataLocation(m_Handle, location, name.c_str() );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(313):    glGetProgramiv( m_Handle, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxLen);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(314):    glGetProgramiv( m_Handle, GL_ACTIVE_UNIFORMS, &nUniforms);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(323):        glGetActiveUniform( m_Handle, i, maxLen, &written, &size, &type, name );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(324):        location = glGetUniformLocation( m_Handle, name );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(341):    glGetProgramiv( m_Handle, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &maxLength);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(342):    glGetProgramiv( m_Handle, GL_ACTIVE_ATTRIBUTES, &nAttribs);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(351):        glGetActiveAttrib( m_Handle, i, maxLength, &written, &size, &type, name );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(352):        location = glGetAttribLocation( m_Handle, name);
Renderers\OGLRenderer\PdrGLSLProgram.cpp(367):    glValidateProgram( m_Handle );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(368):    glGetProgramiv( m_Handle, GL_VALIDATE_STATUS, &status );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(375):        glGetProgramiv( m_Handle, GL_INFO_LOG_LENGTH, &length );
Renderers\OGLRenderer\PdrGLSLProgram.cpp(381):            glGetProgramInfoLog(m_Handle, length, &written, c_log);
Renderers\OGLRenderer\PdrGLSLProgram.inl(11):        int loc = glGetUniformLocation( m_Handle, name.c_str() );
Renderers\OGLRenderer\PdrGLSLProgram.inl(344):    glUniform3f( loc, x, y, z );
Renderers\OGLRenderer\PdrGLSLProgram.inl(351):    glUniform3f( loc, v.x, v.y, v.z );
Renderers\OGLRenderer\PdrGLSLProgram.inl(358):    glUniform4f( loc, v.x, v.y ,v.z, v.w );
Renderers\OGLRenderer\PdrGLSLProgram.inl(365):    glUniform2f( loc, v.x ,v.y );
Renderers\OGLRenderer\PdrGLSLProgram.inl(372):    glUniformMatrix2fv( loc, 1, GL_FALSE, &m[0][0] );
Renderers\OGLRenderer\PdrGLSLProgram.inl(379):    glUniformMatrix3fv( loc, 1, GL_FALSE, &m[0][0] );
Renderers\OGLRenderer\PdrGLSLProgram.inl(386):    glUniformMatrix4fv( loc, 1, GL_FALSE, &m[0][0] );
Renderers\OGLRenderer\PdrGLSLProgram.inl(393):    glUniform1f( loc, val );
Renderers\OGLRenderer\PdrGLSLProgram.inl(400):    glUniform1i( loc, val );
Renderers\OGLRenderer\PdrGLSLProgram.inl(407):    glUniform1i( loc, val );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(27):    glGenBuffers( m_numPBOs, m_pboID );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(31):        glBindBuffer( m_pboTarget, m_pboID[ i ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(32):        glBufferData( m_pboTarget, dataSize, 0, m_pboUsage );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(33):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(41):    glDeleteBuffers( m_numPBOs, m_pboID );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(104):        glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(105):        m_lockedMemoryPtr = glMapBuffer( m_pboTarget, PBOAccess( mlt ) );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(106):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(122):        glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(123):        glUnmapBuffer( m_pboTarget );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(130):            glTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, width, height, format, type, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(132):            glBindTexture( GL_TEXTURE_2D, prevTex );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(137):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(160):            glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(165):            glTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, width, height, format, type, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(166):            glBindTexture( GL_TEXTURE_2D, prevTex );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(168):            glBindBuffer( m_pboTarget, m_pboID[ ( m_index + 1 ) % 2 ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(170):            // Note that glMapBufferARB() causes sync issue.
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(171):            // If GPU is working with this buffer, glMapBufferARB() will wait(stall)
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(173):            // first glBufferDataARB() with NULL pointer before glMapBufferARB().
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(175):            // glMapBufferARB() returns a new allocated pointer immediately
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(177):            glBufferData( m_pboTarget, m_dataSize, 0, m_pboUsage );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(179):            m_lockedMemoryPtr = glMapBuffer( m_pboTarget, PBOAccess( mlt ) );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(181):            glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(196):        glBindBuffer( m_pboTarget, m_pboID[ ( m_index + 1 ) % 2 ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(197):        glUnmapBuffer( m_pboTarget );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(198):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(214):        glReadBuffer( readBufferID );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(216):        glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(217):        glReadPixels( 0, 0, width, height, format, type, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(218):        m_lockedMemoryPtr = glMapBuffer( m_pboTarget, GL_READ_ONLY );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(220):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(233):    glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(234):    glUnmapBuffer( m_pboTarget );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(235):    glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(252):        glReadBuffer( readBufferID );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(254):        glBindBuffer( m_pboTarget, m_pboID[ m_index ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(255):        glReadPixels( 0, 0, width, height, format, type, 0 ); //Async DMA read
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(257):        glBindBuffer( m_pboTarget, m_pboID[ ( m_index + 1 ) % 2 ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(258):        m_lockedMemoryPtr = glMapBuffer( m_pboTarget, GL_READ_ONLY );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(260):        glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(273):    glBindBuffer( m_pboTarget, m_pboID[ ( m_index + 1 ) % 2 ] );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(274):    glUnmapBuffer( m_pboTarget );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(275):    glBindBuffer( m_pboTarget, 0 );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(317):    glGetIntegerv( GL_TEXTURE_BINDING_2D, &prevTex );
Renderers\OGLRenderer\PdrPBOMemTransfer.cpp(318):    glBindTexture( GL_TEXTURE_2D, textureID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(51):    glGenFramebuffers( 1, &m_fboID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(52):    glBindFramebuffer( GL_FRAMEBUFFER, m_fboID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(63):    glBindTexture( GL_TEXTURE_2D, prevTexture );
Renderers\OGLRenderer\PdrRenderTarget.cpp(67):    glBindFramebuffer( GL_FRAMEBUFFER, 0 );
Renderers\OGLRenderer\PdrRenderTarget.cpp(76):        glBindFramebuffer( GL_FRAMEBUFFER, 0 );
Renderers\OGLRenderer\PdrRenderTarget.cpp(77):        glDeleteFramebuffers( 1, &m_fboID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(81):        glDeleteRenderbuffers( 1, &m_depthBufID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(89):    glBindFramebuffer( GL_FRAMEBUFFER, m_fboID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(90):    glDrawBuffers( m_numTargets, &m_drawBuffers[ 0 ] );
Renderers\OGLRenderer\PdrRenderTarget.cpp(92):    glGetIntegerv( GL_VIEWPORT, m_prevViewportCoords );
Renderers\OGLRenderer\PdrRenderTarget.cpp(93):    glGetDoublev( GL_DEPTH_RANGE, m_prevDepthRange );
Renderers\OGLRenderer\PdrRenderTarget.cpp(95):    glViewport( 0, 0, m_width, m_height );
Renderers\OGLRenderer\PdrRenderTarget.cpp(96):    glDepthRange( 0.0, 1.0 );
Renderers\OGLRenderer\PdrRenderTarget.cpp(104):    glBindFramebuffer( GL_FRAMEBUFFER, 0 );
Renderers\OGLRenderer\PdrRenderTarget.cpp(106):    glViewport( m_prevViewportCoords[ 0 ], m_prevViewportCoords[ 1 ], m_prevViewportCoords[ 2 ], m_prevViewportCoords[ 3 ] );
Renderers\OGLRenderer\PdrRenderTarget.cpp(107):    glDepthRange( m_prevDepthRange[ 0 ], m_prevDepthRange[ 1 ] );
Renderers\OGLRenderer\PdrRenderTarget.cpp(175):    glGetIntegerv( GL_TEXTURE_BINDING_2D, &current );
Renderers\OGLRenderer\PdrRenderTarget.cpp(194):        glBindTexture( GL_TEXTURE_2D, pdrTx->GetTextureID() );
Renderers\OGLRenderer\PdrRenderTarget.cpp(198):        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
Renderers\OGLRenderer\PdrRenderTarget.cpp(199):        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
Renderers\OGLRenderer\PdrRenderTarget.cpp(201):        glFramebufferTexture2D( GL_FRAMEBUFFER, m_drawBuffers[ i ], GL_TEXTURE_2D, m_textures[ i ], 0 );
Renderers\OGLRenderer\PdrRenderTarget.cpp(210):    glGenRenderbuffers( 1, &m_depthBufID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(211):    glBindRenderbuffer( GL_RENDERBUFFER, m_depthBufID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(212):    glRenderbufferStorage( GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_width, m_height );
Renderers\OGLRenderer\PdrRenderTarget.cpp(213):    glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthBufID );
Renderers\OGLRenderer\PdrRenderTarget.cpp(221):    auto status = glCheckFramebufferStatus( GL_FRAMEBUFFER );
Renderers\OGLRenderer\PdrShader.cpp(208):            glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_s );
Renderers\OGLRenderer\PdrShader.cpp(209):            glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_t );
Renderers\OGLRenderer\PdrShader.cpp(211):            glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, min_filter );
Renderers\OGLRenderer\PdrShader.cpp(212):            glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, mag_filter );
Renderers\OGLRenderer\PdrShader.cpp(214):            glTexParameterfv( GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, &sampler->GetBorderColor()[ 0 ] );
Renderers\OGLRenderer\PdrShader.cpp(216):            //glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy ); //FIXME: when anisotropy is implemented in texture sampler
Renderers\OGLRenderer\PdrShader.cpp(217):            //glTexEnvf(GL_TEXTURE_FILTER_CONTROL, GL_TEXTURE_LOD_BIAS, lodBias);          //FIXME: when lodbias is implemented in texture sampler
Renderers\OGLRenderer\PdrTexture2D.cpp(58):    glGenTextures   ( 1, &m_textureID );
Renderers\OGLRenderer\PdrTexture2D.cpp(65):        glTexImage2D( GL_TEXTURE_2D, 0, m_internalFormat, m_width, m_height, 0, m_format, m_type, 0 );
Renderers\OGLRenderer\PdrTexture2D.cpp(69):        glTexImage2D( GL_TEXTURE_2D, 0, m_internalFormat, m_width, m_height, 0, m_format, m_type, texture->GetData()->Get() );
Renderers\OGLRenderer\PdrTexture2D.cpp(72):    glBindTexture( GL_TEXTURE_2D, prevTex );
Renderers\OGLRenderer\PdrTexture2D.cpp(81):        glDeleteTextures( 1, &m_textureID );
Renderers\OGLRenderer\PdrTexture2D.cpp(128):    glActiveTexture( GL_TEXTURE0 + textureUnit );
Renderers\OGLRenderer\PdrTexture2D.cpp(139):    glActiveTexture ( GL_TEXTURE0 + textureUnit );
Renderers\OGLRenderer\PdrTexture2D.cpp(172):    glGetIntegerv( GL_TEXTURE_BINDING_2D, &current );
Renderers\OGLRenderer\PdrTexture2D.cpp(173):    glBindTexture( GL_TEXTURE_2D, m_textureID );
Renderers\OGLRenderer\PdrTexture2D.cpp(182):    glBindTexture   ( GL_TEXTURE_2D, m_prevTextureID );     
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(31):    //glGenVertexArrays         ( 1, &m_VaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(32):    //glBindVertexArray         ( m_VaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(33):    //glBindBuffer              (GL_ARRAY_BUFFER, handle[0]);
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(34):    //glVertexAttribPointer     ( (GLuint)0, 3, GL_FLOAT, GL_FALSE, 0, ((GLubyte *)NULL + (0)) );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(36):    glGenVertexArrays( 1, &m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(64):    glDeleteVertexArrays( 1, &m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(87):    glBindVertexArray( m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(94):    glBindVertexArray( 0 );
Renderers\OGLRenderer\PdrVertexArrayObject.cpp(101):    glEnableVertexAttribArray( index );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(33):    glDeleteVertexArrays( 1, &m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(49):        glDeleteVertexArrays( 1, &m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(68):    glBindVertexArray( m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(75):    glBindVertexArray( 0 );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(83):    glEnableVertexAttribArray( index );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(92):    //glGenVertexArrays         ( 1, &m_VaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(93):    //glBindVertexArray         ( m_VaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(94):    //glBindBuffer              (GL_ARRAY_BUFFER, handle[0]);
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(95):    //glVertexAttribPointer     ( (GLuint)0, 3, GL_FLOAT, GL_FALSE, 0, ((GLubyte *)NULL + (0)) );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(97):    glGenVertexArrays( 1, &m_vaoHandle );
Renderers\OGLRenderer\PdrVertexArrayObjectSingleVB.cpp(122):        glVertexAttribPointer( (GLuint) channel, numComponents, GL_FLOAT, GL_FALSE, stride, ptrOffset );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(26):    glDeleteBuffers( 1, &m_bufferHandle );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(51):    GLvoid * vidMem = glMapBuffer( GL_ARRAY_BUFFER, ConstantsMapper::GLConstant( mlt ) );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(64):    glUnmapBuffer( GL_ARRAY_BUFFER );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(82):    glDeleteBuffers( 1, &m_bufferHandle );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(90):    glBindBuffer( GL_ARRAY_BUFFER, m_bufferHandle );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(97):    glBindBuffer( GL_ARRAY_BUFFER, 0 );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(107):    glBufferData( GL_ARRAY_BUFFER, vb->Size(), 0, ConstantsMapper::GLConstant( vb->GetSemantic() ) );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(110):    //glBufferData( GL_ARRAY_BUFFER, vb->Size(), 0, ConstantsMapper::GLConstant( vb->GetSemantic() ) );
Renderers\OGLRenderer\PdrVertexBuffer.cpp(119):    glGenBuffers( 1, &m_bufferHandle );
Renderers\OGLRenderer\PdrVertexDescriptor.cpp(33):    glVertexAttribPointer( (GLuint)index, m_vertexDescriptor->NumComponents( 0 ), GL_FLOAT, GL_FALSE, 0, ((GLubyte *)NULL + (0)) );
Renderers\WGLRenderer\WGLRenderer.cpp(50):    HGLRC windowRC = wglCreateContext( data->m_WindowDC );
Renderers\WGLRenderer\WGLRenderer.cpp(58):    success = wglMakeCurrent( data->m_WindowDC, windowRC );
Renderers\WGLRenderer\WGLRenderer.cpp(92):    wglSwapIntervalEXT = reinterpret_cast< PFNWGLSWAPINTERVALEXTPROC >( wglGetProcAddress( "wglSwapIntervalEXT" ) );
Renderers\WGLRenderer\WGLRenderer.cpp(102):        wglSwapIntervalEXT( 0 );
Renderers\WGLRenderer\WGLRenderer.cpp(151):        wglMakeCurrent( NULL, NULL );
Renderers\WGLRenderer\WGLRenderer.cpp(152):        wglDeleteContext( data->m_WindowRC );
Renderers\Renderer.cpp(104):    glClearColor( m_ClearColor.r, m_ClearColor.g, m_ClearColor.b, m_ClearColor.a );
Renderers\Renderer.cpp(106):    glClearDepth((GLclampd)m_ClearDepth);
Renderers\Renderer.cpp(107):    //glClearStencil((GLint)mClearStencil);
Renderers\Renderer.cpp(108):    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
Renderers\Renderer.cpp(122):    glViewport( 0 , 0, w, h );
Renderers\Renderer.cpp(149):        //glDrawArrays(ConstantsMapper::GLConstant(type), 0, static_cast<TriangleStrip*>(ent)->NumVertices() );
Renderers\Renderer.cpp(172):        glDrawArrays( mode, firstVertex, numVertices );
Renderers\Renderer.cpp(194):    //                           glDrawArrays(vertexArrayObject)
Renderers\Renderer.cpp(565):    glReadPixels( 0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, buf );
