#include "FreeTypeEngine.h"

#include "Engine/Models/Resources/Font/Glyph.h"
#include "Engine/Models/Resources/Font/Text.h"


#include "Engine/Models/Resources/TextureHelpers.h"

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_OUTLINE_H
#include FT_STROKER_H
#include <FreeType/ftglyph.h>

#include <fstream>
#include <iostream>
#include <vector>
#include <map>

namespace bv { namespace model {

struct GlyphDataInfo
{
    Glyph*          glyph;
    unsigned int    pitch;
    char*           data;

    GlyphDataInfo( Glyph* g, unsigned int p, char* d)
        : glyph( g )
        , pitch( p )
        , data( d )
    {}
};


// A horizontal pixel span generated by the FreeType renderer.

struct Span
{
  Span() { }
  Span(int _x, int _y, int _width, int _coverage)
  : x(_x), y(_y), width(_width), coverage(_coverage) { }

  int x, y, width, coverage;
};

typedef std::vector< Span * > Spans;


// *********************************
//
std::map< std::pair< wchar_t, wchar_t >, float >        BuildKerning    ( FT_Face face, const std::wstring & text )
{
    std::map< std::pair< wchar_t, wchar_t >, float > ret;

    for( auto wch0 : text )
    {
        for( auto wch1 : text )
        {
            FT_Vector  kerning;

            auto leftGlyphIndex = FT_Get_Char_Index( face, wch0 );
            auto rightGlyphIndex = FT_Get_Char_Index( face, wch1 );

            auto error = FT_Get_Kerning(    face,           /* handle to face object */
                                            leftGlyphIndex,           /* left glyph index      */
                                            rightGlyphIndex,           /* right glyph index     */
                                            FT_KERNING_DEFAULT,   /* kerning mode          */
                                            &kerning );     /* target vector         */


            if( error == 0 )
            {
                ret[ std::make_pair( wch0, wch1 ) ] = float( kerning.x >> 6 );
            }
        }
    }

    return ret;
}

// *********************************
//
FreeTypeEnginePtr					FreeTypeEngine::Create( const std::string & fontFilePath, size_t fontSize )
{
	return std::make_shared< FreeTypeEngine >( fontFilePath, fontSize );
}

namespace {

struct Vec2
{
  Vec2() { }
  Vec2(float a, float b)
  : x(a), y(b) { }

  float x, y;
};


struct Rect
{
  Rect() { }
  Rect(float left, float top, float right, float bottom)
  : xmin(left), xmax(right), ymin(top), ymax(bottom) { }

  void Include(const Vec2 &r)
  {
    xmin = std::min(xmin, r.x);
    ymin = std::min(ymin, r.y);
    xmax = std::max(xmax, r.x);
    ymax = std::max(ymax, r.y);
  }

  float Width() const { return xmax - xmin + 1; }
  float Height() const { return ymax - ymin + 1; }

  float xmin, xmax, ymin, ymax;
};

void	RasterizeSpans( const Spans & spans, Int32 pitch, char * buffer )
{
	Int32 y = 0;
	for( auto s : spans )
	{
		for (int w = 0; w < s->width; ++w)
			buffer[ pitch * y + s->x + w ] = (char)s->coverage;

		y--;
	}
}

// Each time the renderer calls us back we just push another span entry on
// our list.

void
RasterCallback(const int y,
               const int count,
               const FT_Span * const spans,
               void * const user) 
{
  Spans *sptr = (Spans *)user;
  for (int i = 0; i < count; ++i) 
    sptr->push_back(new Span( spans[i].x, y, spans[i].len, spans[i].coverage));
}


// Set up the raster parameters and render the outline.

void
RenderSpans(FT_Library &library,
            FT_Outline * const outline,
            Spans *spans) 
{
  FT_Raster_Params params;
  memset(&params, 0, sizeof(params));
  params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
  params.gray_spans = RasterCallback;
  params.user = spans;

  FT_Outline_Render(library, outline, &params);
}

}


FreeTypeEngine::FreeTypeEngine( const std::string & fontFilePath, size_t fontSize )
	: m_fontSize( fontSize )
{
	if (FT_Init_FreeType (&m_library))
    {
        std::cerr << "Could not init FreeType library\n" << std::endl;
    }

    if (FT_New_Face (m_library, fontFilePath.c_str(), 0, &m_face))
    {
        std::cerr << "Could not open font\n" << std::endl;
    }

	FT_Set_Pixel_Sizes( m_face, (FT_UInt)m_fontSize, (FT_UInt)m_fontSize );
}

// *********************************
//
const Glyph*						FreeTypeEngine::RenderGlyph( wchar_t ch, std::vector< Span * > & spans )
{
    // Load the glyph we are looking for.
    FT_UInt gindex = FT_Get_Char_Index(m_face, ch);

    if (FT_Load_Glyph(m_face, gindex, FT_LOAD_NO_BITMAP) == 0)
    {
		// Need an outline for this to work.
		if (m_face->glyph->format == FT_GLYPH_FORMAT_OUTLINE)
		{
			// Render the basic glyph to a span list.
			RenderSpans(m_library, &m_face->glyph->outline, &spans);

			FT_Glyph glyph;
			if (FT_Get_Glyph(m_face->glyph, &glyph) == 0)
			{
				// Now we need to put it all together.
				if (!spans.empty())
				{
					// Figure out what the bounding rect is for both the span lists.
					Rect rect(	(float)spans.front()->x,
								(float)spans.front()->y,
								(float)spans.front()->x,
								(float)spans.front()->y);
					for (Spans::iterator s = spans.begin();
							s != spans.end(); ++s)
					{
						rect.Include(Vec2((float)(*s)->x, (float)(*s)->y));
						rect.Include(Vec2((float)((*s)->x + (*s)->width - 1), (float)(*s)->y));
					}

					// This is unused in this test but you would need this to draw
					// more than one glyph.
					float bearingX = float(m_face->glyph->metrics.horiBearingX >> 6);
					float bearingY = float(m_face->glyph->metrics.horiBearingY >> 6);
					float advance = float(m_face->glyph->advance.x >> 6);

					// Get some metrics of our image.
					int imgWidth = (int)rect.Width(),
						imgHeight = (int)rect.Height(),
						imgSize = imgWidth * imgHeight;

			        auto newGlyph = new Glyph();

			        newGlyph->code = ch;
					newGlyph->size = m_fontSize;
			        newGlyph->width = (int)rect.Width();
			        newGlyph->height = (int)rect.Height();

			        if( (int)newGlyph->height > m_maxHeight )
			            m_maxHeight = (Int32)newGlyph->height;

			        if( (int)newGlyph->width > m_maxWidth )
			            m_maxWidth = (Int32)newGlyph->width;


			        newGlyph->bearingX = bearingX;
			        newGlyph->bearingY = bearingY;
			        newGlyph->advanceX = m_face->glyph->advance.x >> 6;
			        newGlyph->advanceY = m_face->glyph->advance.y >> 6;

					return newGlyph;
				}
			}
		}
	}

	return nullptr;
}

// *********************************
//
const TextAtlas *	FreeTypeEngine::CreateAtlas( SizeType padding, const std::wstring & wcharsSet )
{

	SizeType							glyphsNum	= wcharsSet.size();
	Int32								spadding	= (Int32)padding;

	std::map< wchar_t, const Glyph * >	glyphs;
	std::map< wchar_t, Spans >			spans;

    for ( auto ch : wcharsSet )
    {
		spans[ ch ] = Spans();
		glyphs[ ch ] = RenderGlyph( ch, spans[ ch ] );
	}

	auto atlasSize = (SizeType) std::ceil( sqrt( (float)glyphsNum ) );

    auto maxWidth  = m_maxWidth		+ spadding * 2;
    auto maxHeight = m_maxHeight	+ spadding * 2;

    auto altlasWidth	= maxWidth	* atlasSize;
    auto altlasHeight	= maxHeight * atlasSize;

    auto atlas = TextAtlas::Crate( altlasWidth, altlasHeight, 8, maxWidth, maxHeight );

    char* atlasData = const_cast< char * >( atlas->GetWritableData()->Get() );// FIXME: Remove const_cast

    auto atlasColumns  =  altlasWidth / maxWidth;

	Int32 x = 0;
	Int32 y = 0;

	for( SizeType y = 0; y < atlasSize; ++y )
		for( SizeType x = 0; x < atlasSize; ++x )
		{
			if( y * x < wcharsSet.size() )
			{
				auto ch = wcharsSet[ y * x ];
				auto & sps = spans[ ch ];
				auto glyph = glyphs[ ch ];

				auto xyDataShift = y * altlasWidth + x * maxWidth;

				RasterizeSpans( sps, altlasWidth, &atlasData[ xyDataShift + maxHeight * altlasWidth + (maxWidth - glyph->width) ] );
			}
		}

	TextureHelper::WriteBMP( "testFreeType.bmp", atlas->GetWritableData(), altlasWidth, altlasHeight, 8 );

 //   std::vector<bool>   textureCoordsSet( glyphsDataInfos.size(), false );


 //   for (SizeType y = 0; y < atlas->GetHeight(); y++) 
 //   {
 //       for (SizeType x = 0; x < atlas->GetWidth(); x++)
 //       {
 //   
 //           // work out which grid slot[col][row] we are in e.g out of 16x16
 //           SizeType col = x / maxWidth;
 //           SizeType row = y / maxHeight;
 //           SizeType order = row * atlasColumns + col;

 //           SizeType dataElem = y * atlas->GetWidth() * atlas->GetBitsPerPixel() / 8 + ( x * atlas->GetBitsPerPixel() / 8 );

 //           if( order < 0 || order >= glyphsDataInfos.size() )
 //           {
 //               atlasData[ dataElem ] = 0;
 //               atlasData[ dataElem + 1 ] = 0;
 //               atlasData[ dataElem + 2 ] = 0;
 //               atlasData[ dataElem + 3 ] = 0;
 //               continue;
 //           }

 //           // pixel indices within padded glyph slot area
 //           Int32 x_loc = (x % maxWidth)	- ( maxWidth	- ((Int32)glyphsDataInfos[order].glyph->width ) ) + spadding;
 //           Int32 y_loc = (y % maxHeight)	- ( maxHeight	- ((Int32)glyphsDataInfos[order].glyph->height) ) + spadding;


 //           if( !textureCoordsSet[ order ] )
 //           {
 //               glyphsDataInfos[order].glyph->textureX = x + padding;
 //               glyphsDataInfos[order].glyph->textureY = y + padding;
 //               textureCoordsSet[ order ] = true;
 //               atlas->SetGlyphCoords(
 //                       glyphsDataInfos[order].glyph->code
 //                   ,   GlyphCoords(    glyphsDataInfos[order].glyph->textureX
 //                                   ,   glyphsDataInfos[order].glyph->textureY
 //                                   ,   maxWidth - 2 * spadding
 //                                   ,   maxHeight - 2 * spadding
 //                                   ,   (maxWidth - 2 * spadding ) - (int)glyphsDataInfos[order].glyph->width
 //                                   ,   (maxHeight - 2 * spadding ) - (int)glyphsDataInfos[order].glyph->height
 //                                   ,   glyphsDataInfos[order].glyph->width
 //                                   ,   glyphsDataInfos[order].glyph->height
 //                                   ,   glyphsDataInfos[order].glyph->bearingX
 //                                   ,   glyphsDataInfos[order].glyph->bearingY
 //                                   ,   glyphsDataInfos[order].glyph->advanceX
 //                                   ,   glyphsDataInfos[order].glyph->advanceY )
 //                   );
 //           }
 //               
 //           if (x_loc < 0 || y_loc < 0 || x_loc >= (int)glyphsDataInfos[order].glyph->width || y_loc >= (int)glyphsDataInfos[order].glyph->height )
 //           {
 //               atlasData[ dataElem ] = 0;
 //               atlasData[ dataElem + 1 ] = 0;
 //               atlasData[ dataElem + 2 ] = 0;
 //               atlasData[ dataElem + 3 ] = 0;
 //           } 
 //           else 
 //           {
 //               // this is 1, but it's safer to put it in anyway
 //               auto bytes_per_pixel = glyphsDataInfos[order].glyph->width / glyphsDataInfos[order].pitch;
 //               auto bytes_in_glyph  = glyphsDataInfos[order].glyph->height * glyphsDataInfos[order].pitch;
 //               auto byte_order_in_glyph = y_loc * glyphsDataInfos[order].glyph->width + x_loc;
 //               // print byte from glyph
 //               auto p = glyphsDataInfos[order].data[byte_order_in_glyph];
 //               atlasData[ dataElem ] = p;
 //               atlasData[ dataElem + 1 ] = p;
 //               atlasData[ dataElem + 2 ] = p;
 //               atlasData[ dataElem + 3 ] = p;
 //           }
 //       }
 //   }

	//atlas->m_kerningMap = BuildKerning( face, wcharsSet );

	//return atlas;
	return nullptr;
}

// *********************************
//
const TextAtlas *	FreeTypeEngine::CreateAtlas( SizeType padding, SizeType outline, const std::wstring & wcharsSet )
{
	return nullptr;
}

} // bv
} // model

namespace {
//#define MAKE_FREETYPE_TESTING_TEXT

#ifdef MAKE_FREETYPE_TESTING_TEXT

unsigned char * output = nullptr;

void my_draw_bitmap( FT_Bitmap* bitmap, int pen_x, int pen_y )
{
    for( int y = 0; y < bitmap->rows; ++y )
    {
        for( int x = 0; x < bitmap->width; ++x )
        {
            float alpha = bitmap->buffer[ y * bitmap->pitch + x ] / 255.f;

            float topCol = float( bitmap->buffer[ y * bitmap->pitch + x ] ) * alpha;
            float backCol = float( output[ ( ( pen_y + y ) * 1920 + ( pen_x + x ) ) * 4 ] ) * ( 1.f - alpha );

            output[ ( ( pen_y + y ) * 1920 + ( pen_x + x ) ) * 4 ] = unsigned char( topCol + backCol );
            output[ ( ( pen_y + y ) * 1920 + ( pen_x + x ) ) * 4 + 1 ] = unsigned char( topCol + backCol );
            output[ ( ( pen_y + y ) * 1920 + ( pen_x + x ) ) * 4 + 2 ] = unsigned char( topCol + backCol );
            output[ ( ( pen_y + y ) * 1920 + ( pen_x + x ) ) * 4 + 3 ] = unsigned char( topCol + backCol );
        }
    }
}

void GenrateTestFreeTypeText( const std::wstring& text, FT_Face face )
{
    output = new unsigned char[ 1920 * 1080 * 4 ];
    memset( output, 0, sizeof( output ) );


  FT_GlyphSlot  slot = face->glyph;  /* a small shortcut */
  FT_UInt       glyph_index;
  FT_Bool       use_kerning;
  FT_UInt       previous;
  int           pen_x, pen_y, n;

  pen_x = 200;
  pen_y = 300;

  use_kerning = FT_HAS_KERNING( face );
  previous    = 0;

  for ( n = 0; n < (int)text.size(); n++ )
  {
      std::cout << "char "  << text[n] << std::endl;
    /* convert character code to glyph index */
    glyph_index = FT_Get_Char_Index( face, text[n] );

    /* retrieve kerning distance and move pen position */
    if ( use_kerning && previous && glyph_index )
    {
      FT_Vector  delta;


      FT_Get_Kerning( face, previous, glyph_index,
                      FT_KERNING_DEFAULT, &delta );

      pen_x += delta.x >> 6;

      std::cout << "kerning " << ( delta.x >> 6 ) << std::endl;
    }

    /* load glyph image into the slot (erase previous one) */
    auto error = FT_Load_Glyph( face, glyph_index, FT_LOAD_RENDER );
    if ( error )
      continue;  /* ignore errors */

    /* now draw to our target surface */
    my_draw_bitmap( &slot->bitmap,
                    pen_x + slot->bitmap_left,
                    pen_y - slot->bitmap_top );

    std::cout << "pen_x "  << pen_x << " pen_y " << pen_y << std::endl;

    /* increment pen position */
    pen_x += slot->advance.x >> 6;

    std::cout << "advance.x "  << ( slot->advance.x >> 6 ) << std::endl;

    /* record current glyph index */
    previous = glyph_index;
  }

  TextureHelper::WriteBMP( "testFreeType.bmp", MemoryChunkConstPtr( new MemoryChunk( ( char* )output, 1920 * 1080 * 4 ) ), 1920, 1080, 32 );

}

#endif // MAKE_FREETYPE_TESTING_TEXT

} // anonymous